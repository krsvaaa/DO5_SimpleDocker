## Part 1. Готовый докер

1. Беру официальный докер-образ с nginx и качаю его при помощи ``docker pull```

![a](img/1.1.jpg)

2. Проверяю наличие докер-образа через ```docker images```

![a](img/1.2.jpg)

3. Запускаю докер-образ через ```docker run -d [image_id|repository]```

![a](img/1.3.jpg)

4. Проверяю, что образ запустился через ```docker ps```

![a](img/1.4.jpg)

5. Смотрю информацию о контейнере через ```docker inspect [container_id|container_name]```

![a](img/1.5.jpg)

![a](img/1.6.jpg)


   размер контейнера:
   
   ![a](img/1.7.jpg)
   
   список замапленных портов:
   
   ![a](img/1.8.jpg)
   
   ip контейнера:
   
   ![a](img/1.9.jpg)
   
 6. Останавливаю докер контейнер через ```docker stop [container_id|container_name]``` и проверяю через ```docker ps```


![a](img/1.10.jpg)

7. Запускаю докер с портами 80 и 443 командой ```docker run -p 80:80 -p 443:443 nginx```

![a](img/1.11.jpg)

8. В браузере ввожу ```localhost:80```. Появляется стартовая страница nginx

![a](img/1.12a.jpg)

![a](img/1.12.jpg)

9. Перезапускаю докер ```docker restart``` и проверяю его состояние

![a](img/1.13.jpg)

## Part 2. Операции с контейнером



1. Вывожу содержимое файла конфигурации в контейнере ```docker exec nostalgic_perlman cat /etc/nginx/nginx.conf```

![a](img/2.1.jpg)

2. Создаю на машине файл nginx.conf и добавляю туда по пути /status отдачу страницы статуса сервера nginx

![a](img/2.2.jpg)

3. Копирую файл в докер ```docker cp nginx.conf nostalgic_perlman:/etc/nginx/```

![a](img/2.3.jpg)

4. Перезапускаю nginx

![a](img/2.4.jpg)

5. Командой ```docker exec -it mystifying_kepler curl http://localhost/status``` проверяю статус nginx

![a](img/2.5.jpg)

6. Эскпортирую контейнер

![a](img/2.6.jpg)

7. Останавливаю его

![a](img/2.7.jpg)

8. Сначала удаляю образ 

![a](img/2.8.jpg)

9. Затем удаляю контейнер



![a](img/2.10.jpg)

10. Импортирую сохраненный контейнер


![a](img/2.11.jpg)

11. Проверяю контейнер через ```docker images```


![a](img/2.12.jpg)

12. Запускаю контейнер 

![a](img/2.13.jpg)

13. Проверяю статус nginx через curl

![a](img/2.14.jpg)

## Part 3. Мини веб-сервер

1. Создаю файл server.c, который будет выводить Hello, World!

![a](img/3.1.jpg)

2. Запускаю докер

![a](img/3.1a.jpg)

3. Компилирую server.c и копирую на докер 

![a](img/3.2a.jpg)

![a](img/3.2.jpg)

4. Изменяю nginx.conf, чтобы он проксировал все запросы с 81 порта на 127.0.0.1:8080


![a](img/3.4.jpg)

5. Копирую nginx.conf на докер

![a](img/3.5.jpg)

6. Захожу в докер


![a](img/3.3.jpg)

7. Качаю нужные пакеты

![a](img/3.6.jpg)

8. Перезапускаю nginx

![a](img/3.7a.jpg)

9. Запускаю сервер на порту 8080 

![a](img/3.7.jpg)

10. Прохожу по адресу ```http://localhost:81```

![a](img/3.8.jpg)


## Part 4. Свой докер

1. Устанавливаю нужные пакеты

![a](img/4.1.jpg)

![a](img/4.2.jpg)

2. Создаю Dockerfile

![a](img/4.3.jpg)

3. Редактирую, добавляю в него строки, которые:
	1. указывают рабочую директорию
	2. копируют из директории файл конфигурации nginx.conf
	3. купируют скрипт мини-сервера из части 3
	4. устанавливают нужные пакеты


![a](img/4.4.jpg)



6. Создаю скрипт build.sh, который будет компилировать server.c и запускать сервер на порту 8080

![a](img/4.6.jpg)

7. Добавляю entrypoint с написанным скриптом в Dockerfile и строки которые будут копировать build.sh и делать его исполняемым

![a](img/4.7.jpg)

8. Монтирую образ с именем etsyhone и тегом b

![a](img/4.8.jpg)



9. Проверяю, что все прошло успешно


![a](img/4.10.jpg)

10. Запускаю образ с маппингом с 81 на 80 порт и маппингом файла конфигурации nginx внутри контейнера и проверяю работу с помощью ```docker ps```

![a](img/4.11.jpg)

11. Проверяю через curl страницу ```localhost:80```

![a](img/4.12.jpg)

12. Добавляю в nginx.conf проксирование страницы ```status```, которая будет отображать статус nginx

![a](img/4.13.jpg)

13. Останавливаю контейнер

![a](img/4.14.jpg)

14. Пересобираю его

![a](img/4.15.jpg)



15. Запускаю с маппингом с 81 на 80 порт и маппингом файла конфигурации nginx и проверяю через ```docker ps```

![a](img/4.17.jpg)

16. С помощью curl вывожу содержимое страницы ```localhost:80/status```

![a](img/4.18.jpg)

## Part 5. Dockle

1. Устанавливаю Dockle строкой:

``` 
VERSION=$(
 curl --silent "https://api.github.com/repos/goodwithtech/dockle/releases/latest" | \
 grep '"tag_name":' | \
 sed -E 's/.*"v([^"]+)".*/\1/' \
) && curl -L -o dockle.deb https://github.com/goodwithtech/dockle/releases/download/v${VERSION}/dockle_${VERSION}_Linux-64bit.deb
$ sudo dpkg -i dockle.deb && rm dockle.deb
```

2. Проверяю свой докер и вижу ошибки

![a](img/5.1.jpg)

![a](img/5.2.jpg)

![a](img/5.3.jpg)

3. Исправляю докерфайл, добавляю строку удаления кэшированных файлов после установки, создаю и перехожу на нового пользователя

![a](img/5.4.jpg)

4. Запускаю докер

![a](img/5.5.jpg)

5. Проверяю с помощью Dockle. Остается только одна ошибка, связанная со специфичными ключами шифрования, хранящимися в образе, на основе которого мы создавали свой
 
 ![a](img/5.6.jpg)
 
 ![a](img/5.7.jpg)
 
 6. Чтобы программа не ругалась на ключи, нужно ввести 
 
``` 
DOCKLE_ACCEPT_KEYS=NGINX_GPGKEYS,NGINX_GPGKEYS,NGINX_GPGKEY_PATH dockle -d etsyhone:b
```

 ![a](img/5.8.jpg)
 
 ## Part 6. Базовый Docker Compose
 
 1. Создаю docker-compose.yml, который будет поднимать образ в текущей папке и второй образ из nginx. Добавляю строчку, при которой запросы, поступающие на хост по адресу localhost:80, перенаправляются на второй контейнер по порту 8080. Копирую содержимое nginx.conf на второй образ
 
  ![a](img/6.1.jpg)

2. Изменяю nginx.conf, чтобы проксировать все запросы с 8080 порта на 81 порт первого контейнера

  ![a](img/6.2.jpg)
  
  3. Проверяю и останавливаю все запущенные докеры

  ![a](img/6.3.jpg)
  
  4. Собираю докер (```docker compose build``` ```docker compose up```). ```docker compose up``` транслирует все процессы при сборке. флаг -d делает сборку тихой

  ![a](img/6.4.jpg)
  
  ![a](img/6.5.jpg)
  
  ![a](img/6.6.jpg)
  
  ![a](img/6.7.jpg)
  
  5. Ввожу ```curl localhost:80```.  Выходит Hello World!
 
   ![a](img/6.8a.jpg)
